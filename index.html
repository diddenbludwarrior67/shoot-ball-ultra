<!DOCTYPE html>
<html>
<head>
  <title>Orb Shooter Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
</head>
<body>
<script>
let player;
let orbs = [];
let projectiles = [];
let score = 0;
let currentWeapon = 0;
let weapons = [
  { name: "Single Shot", fireRate: 13, speed: 10, damage: 1, color: 'blue', cost: 0 },
  { name: "Double Shot", fireRate: 18, speed: 10, damage: 1, color: 'green', cost: 100 },
  { name: "Triple Shot", fireRate: 25, speed: 12, damage: 2, color: 'red', cost: 250 },
  { name: "Spread Shot", fireRate: 35, speed: 8, damage: 1, color: 'purple', cost: 500 },
  { name: "Minigun", fireRate: 3, speed: 15, damage: 1, color: 'yellow', cost: 1000 },
  { name: "RPG", fireRate: 15, speed: 9, damage: 50, color: 'orange', cost: 2000, explosionRadius: 70 },
  { name: "The Destroyer", fireRate: 80000, speed: 5050505050, damage: 4040404040, color: [255, 0, 0], cost: 1000000 }
  { name: "Ultra Gun Dude", fireRate: 500000, speed: 5454544577775475476476547645, damage:777999999999999999, color: [0, 0, 0], cost: 67676767}
];
let frameCounter = 0;
let boss = null;
let gameWon = false;

function setup() {
  createCanvas(1200, 800);
  player = new Player();
}

function draw() {
  if (gameWon) {
    background(0);
    fill(255);
    textSize(50);
    textAlign(CENTER);
    text("You Win! Game Beaten!", width / 2, height / 2);
    return;
  }

  background(0);
  frameCounter++;
  
  // Spawn orbs if boss not present
  if (!boss && frameCounter % 60 === 0) {
    let rand = random();
    let isGolden = rand < 0.001; // 0.1% Golden
    let isBIG = !isGolden && rand < 0.50; // 5% BIG
    let isElite = !isGolden && !isBIG && rand < 0.031; // 2% Elite
    let isBig = !isGolden && !isBIG && !isElite && rand < 0.231; // ~20% Big
    orbs.push(new Orb(isBig, isBIG, isGolden, isElite));
  }
  
  // Spawn boss at 500000 score
  if (score >= 500000 && !boss) {
    boss = new Boss();
  }
  
  // Update and draw player
  player.update();
  player.show();
  
  // Check for shooting with W key
  if (keyIsDown(87)) {
    player.shoot();
  }
  
  // Update and draw projectiles
  for (let i = projectiles.length - 1; i >= 0; i--) {
    projectiles[i].update();
    projectiles[i].show();
    if (projectiles[i].offscreen()) {
      projectiles.splice(i, 1);
      continue;
    }
    // Check collisions with orbs
    for (let j = orbs.length - 1; j >= 0; j--) {
      if (projectiles[i] && projectiles[i].hits(orbs[j])) {
        let proj = projectiles[i];
        let damage = proj.damage;
        if (proj.explosionRadius > 0) {
          let explodePos = proj.pos;
          let toRemove = [];
          for (let k = 0; k < orbs.length; k++) {
            if (dist(explodePos.x, explodePos.y, orbs[k].pos.x, orbs[k].pos.y) < proj.explosionRadius) {
              orbs[k].health -= damage;
              if (orbs[k].health <= 0) {
                score += orbs[k].points;
                toRemove.push(k);
              }
            }
          }
          toRemove.sort((a, b) => b - a);
          for (let idx of toRemove) {
            orbs.splice(idx, 1);
          }
        } else {
          orbs[j].health -= damage;
          if (orbs[j].health <= 0) {
            score += orbs[j].points;
            orbs.splice(j, 1);
          }
        }
        projectiles.splice(i, 1);
        break;
      }
    }
    // Check collision with boss if present
    if (boss && projectiles[i] && projectiles[i].hits(boss)) {
      let proj = projectiles[i];
      let damage = proj.damage;
      if (proj.explosionRadius > 0) {
        boss.health -= damage;
      } else {
        boss.health -= damage;
      }
      projectiles.splice(i, 1);
      if (boss.health <= 0) {
        boss = null;
        gameWon = true;
      }
    }
  }
  
  // Update and draw orbs
  for (let i = orbs.length - 1; i >= 0; i--) {
    orbs[i].update();
    orbs[i].show();
    if (orbs[i].offscreen()) {
      orbs.splice(i, 1);
    }
  }
  
  // Update and draw boss if present
  if (boss) {
    boss.show();
  }
  
  // Display score and weapon info
  fill(255);
  textSize(20);
  text(`Score: ${score}`, 10, 30);
  text(`Weapon: ${weapons[currentWeapon].name}`, 10, 60);
  
  // Check for weapon upgrades
  for (let i = weapons.length - 1; i > currentWeapon; i--) {
    if (score >= weapons[i].cost) {
      currentWeapon = i;
    }
  }
}

class Player {
  constructor() {
    this.pos = createVector(width / 2, height - 50);
    this.size = 20;
  }
  
  update() {
    this.pos.x = constrain(mouseX, this.size, width - this.size);
  }
  
  show() {
    fill(255);
    rectMode(CENTER);
    rect(this.pos.x, this.pos.y, this.size * 2, this.size);
  }
  
  shoot() {
    if (frameCounter % weapons[currentWeapon].fireRate === 0) {
      let weapon = weapons[currentWeapon];
      if (weapon.name === "Single Shot") {
        projectiles.push(new Projectile(this.pos.x, this.pos.y, weapon));
      } else if (weapon.name === "Double Shot") {
        projectiles.push(new Projectile(this.pos.x - 10, this.pos.y, weapon));
        projectiles.push(new Projectile(this.pos.x + 10, this.pos.y, weapon));
      } else if (weapon.name === "Triple Shot") {
        projectiles.push(new Projectile(this.pos.x, this.pos.y, weapon));
        projectiles.push(new Projectile(this.pos.x - 15, this.pos.y, weapon));
        projectiles.push(new Projectile(this.pos.x + 15, this.pos.y, weapon));
      } else if (weapon.name === "Spread Shot") {
        for (let i = -2; i <= 2; i++) {
          let angle = i * 0.2;
          projectiles.push(new Projectile(this.pos.x, this.pos.y, weapon, angle));
        }
      } else if (weapon.name === "Minigun") {
        projectiles.push(new Projectile(this.pos.x, this.pos.y, weapon));
      } else if (weapon.name === "RPG") {
        projectiles.push(new Projectile(this.pos.x, this.pos.y, weapon));
      } else if (weapon.name === "The Destroyer") {
        projectiles.push(new Projectile(this.pos.x, this.pos.y, weapon));
      }
    }
  }
}

class Projectile {
  constructor(x, y, weapon, angle = 0) {
    this.pos = createVector(x, y);
    this.vel = createVector(angle, -weapon.speed);
    this.size = 5;
    this.color = weapon.color;
    this.damage = weapon.damage;
    this.explosionRadius = weapon.explosionRadius || 0;
  }
  
  update() {
    this.pos.add(this.vel);
  }
  
  show() {
    if (Array.isArray(this.color)) {
      fill(this.color[0], this.color[1], this.color[2]);
    } else {
      fill(this.color);
    }
    noStroke();
    ellipse(this.pos.x, this.pos.y, this.size * 2);
  }
  
  offscreen() {
    return this.pos.y < 0;
  }
  
  hits(target) {
    let d = dist(this.pos.x, this.pos.y, target.pos.x, target.pos.y);
    return d < this.size + target.size;
  }
}

class Orb {
  constructor(isBig = false, isBIG = false, isGolden = false, isElite = false) {
    this.pos = createVector(random(width), 0);
    this.baseX = this.pos.x;
    this.phase = random(TWO_PI);
    if (isGolden) {
      this.size = 10;
      this.health = 1;
      this.points = 1000000;
      this.vel = createVector(0, random(5, 8));
      this.amplitude = 200;
      this.color = [255, 215, 0]; // Gold
    } else if (isBIG) {
      this.size = 50;
      this.health = 20;
      this.points = 200;
      this.vel = createVector(0, random(2, 4));
      this.amplitude = 150;
      this.color = [128, 0, 128]; // Purple
    } else if (isElite) {
      this.size = 20;
      this.health = 1;
      this.points = 1000;
      this.vel = createVector(0, random(3, 5));
      this.amplitude = 80;
      this.color = [0, 0, 255]; // Blue
    } else if (isBig) {
      this.size = 30;
      this.health = 5;
      this.points = 50;
      this.vel = createVector(0, random(3, 6));
      this.amplitude = 100;
      this.color = [255, 0, 0]; // Red
    } else {
      this.size = 15;
      this.health = 1;
      this.points = 10;
      this.vel = createVector(0, random(2, 5));
      this.amplitude = 50;
      this.color = [255, 255, 0]; // Yellow
    }
  }
  
  update() {
    this.pos.x = this.baseX + sin(frameCounter * 0.05 + this.phase) * this.amplitude;
    this.pos.y += this.vel.y;
  }
  
  show() {
    fill(this.color[0], this.color[1], this.color[2]);
    noStroke();
    ellipse(this.pos.x, this.pos.y, this.size * 2);
    if (this.health > 1) {
      fill(255);
      textSize(12);
      textAlign(CENTER);
      text(this.health, this.pos.x, this.pos.y + this.size + 10);
    }
  }
  
  offscreen() {
    return this.pos.y > height;
  }
}

class Boss {
  constructor() {
    this.pos = createVector(width / 2, 100);
    this.size = 100;
    this.health = 10000;
    this.color = [0, 0, 0]; // Black
  }
  
  show() {
    fill(this.color[0], this.color[1], this.color[2]);
    noStroke();
    ellipse(this.pos.x, this.pos.y, this.size * 2);
    fill(255);
    textSize(20);
    textAlign(CENTER);
    text(this.health, this.pos.x, this.pos.y + this.size + 20);
  }
}
</script>
</body>
</html>
